Command to run VS with breakpoints in VS command prompt

Step 1: C:\MSR-Research\corral>bin\Debug\corral.exe test\regression\001\001.bpl /flags:test\regression\001\config /break
Step 2: Set the breakpoint in the code by clicking on the margin along the side of the corresponding code line 
Step 3: Click Debug --> Continue
Step 4: To Step through each line including function call, press F11.
Step 5: To step over skipping functions, press F10.

https://msdn.microsoft.com/en-us/library/y740d9d3.aspx

>> Command to print the program (in bpl) after various instrumentation steps and before calling BoogieVerify.verifier 
C:\MSR-Research\corral>bin\Debug\corral.exe test\regression\test0\main.bpl 
/flags:test\regression\cex\config /trackAllVars /v:3 /printFinalProg:test\regression\test0\ir.bpl

>> BoogieVerify.verifier is called from driver.cs Line 576
   var rstatus = BoogieVerify.Verify(init, out err, true);

>> Command to execute ONLY the Stratified inlining procedure (/si) on the Instrumented program. Note that the instrumented program 
   is obtained from the /printFinalProg argument shown above.
   C:\MSR-Research\corral>bin\Debug\corral.exe test\regression\test0\ir.bpl /flags:test\regression\cex\config /trackAllVars /si /v:3

>> Set recursion bound with /recursionBound:2 

>> The config file says how many counterexample to return by setting cex:N

>> /trackAllVars is used to block Hierarchical refinement loop in Corral

>> Stratified inlining use function summary as assume(true) -- even when Houdini is used. 

>> verbose > 2 prints the counterexample trace obtained from overapproximate query. It returns a 
symbolic trace which just contains the name of the basic blocks. This means the whole basic block 
is included in the trace. 

>> Command to run the Backtrack based parallelization of the Corral algorithm (implemented by Akash)
   C:\MSR-Research\corral>bin\Debug\corral.exe test\regression\cex\loopassert.bpl /flags:test\regression\cex\config  
   /trackAllVars /v:2 /newStratifiedInlining:split /di /doNotUseLabels

>> OnModel() procedure in StratifiedInlining.cs maps the z3 model to the counterexample trace of program. 

>> The over-approximate query simply replace the function call with assume(true). This means any global variable 
like assertsPassed that this function modifies can have arbitrary value. 

>> Command to run Corral with NO underapproximation: /newStratifiedInlining:nounder

>> The stratifiedInlining algorithm with alternation of over and under approximation has to do 
pop() from z3 after the underapproximate query since an underapproximate query blocks a callsite. 
The popping can be inefficient sometimes and may lead to more time. 

>> The counterexample is shown in terms of basic blocks. The call sites that appear in those 
basic blocks are chosen to be inlined next.

>> How to assert that a basic block is taken (only happens with split style stratified inlining) 
    -- follow AssertMustReach procedure

>> svc.mustReachVar gives the list of basic blocks for the callsite which we MUST want to reach

>> bin\Debug\corral.exe test\regression\test3\main.bpl /flags:test\regression\test3\config  
/trackAllVars /v:3 /newStratifiedInlining:mustreach /di /doNotUseLabels /break

>> A result of Underapproximate query (if unsat) never leads to extending any call site. 
It is always followed by an over-approximate query. So, underapproximation query (if satisfiable) 
is always used for earlier bug detection. However, for safe programs, underapproximate queries 
are an overhead since it increases Z3 query as well as leads to frequent Pops which is expensive.

>> Safe Boogie program: If every path in the program is non-blocking with respect to the global variable assertPassed, 
that is, if a boogie program returns from main, then it is safe. 
   Unsafe Boogie program: If there exists some path in the program which is blocking with respect to the variable 
   assertPassed, that is, assertPassed = true and assume !assertPassed is reached through this path, then the 
   program is unsafe.

Findinds:
1> Baseline approach is always over-approximate (Good for safe cases) -- Or every 10th query is an Under-approximate query.
2> 



Example 1: 
==========
var x: int;

procedure {:entrypoint} main()
{
   havoc x;
   assert x ==  1;
}

C:\MSR-Research\corral>bin\Debug\corral.exe test\regression\test0\main.bpl /flags:test\regression\cex\config /trackAllVars /v:2
Warning: Using default recursion bound of 1
Single threaded program detected
Verifying program while tracking: {assertsPassed, x}
Starting forward approach...
  - underapprox
    - check
    - checked: Correct
  - overapprox
    - check
    - checked: Errors
    ~ extend callsite main
  - underapprox
    - check
    - checked: Errors
--------- Stats ---------
number of functions inlined: 1
number of backtracking: 0
total number of assertions in Z3 stack: 0
total number of Z3 calls: 3
total time spent in Z3: (tick) 1601
-------------------------
Program has a potential bug: Starting forward approach...
    ~ extend callsite main_trace_1
  - underapprox
    - check
    - checked: Errors
--------- Stats ---------
number of functions inlined: 1
number of backtracking: 0
total number of assertions in Z3 stack: 0
total number of Z3 calls: 1
total time spent in Z3: (tick) 20
-------------------------
True bug
PersistentProgram(13,1): error PF5001: This assertion can fail

main.bpl(6,1): error PF5001: This assertion can fail

Execution trace:
Format: (tid,k)  filename(line,col): blockName   (extra info)
(1,0)    test\regression\test0\main.bpl(5,4): anon0
(1,0)    test\regression\test0\main.bpl(5,4): anon0
(1,0)    test\regression\test0\main.bpl(6,4): anon0  (ASSERTION FAILS assert x == 1;
 )
(1,0)    test\regression\test0\main.bpl(6,4): anon0  (Done)
LOC on trace: 3
Unique procs inlined: 1
Total number of procs: 1
LOC inlined: 0 out of 0
Non-trivial procs: 0
Trace length (LOC): 0
Trace length (branches): {}

Boogie verification time: 0.19 s
Time spent reading-writing programs: 0.03 s

Time spent checking a program (1): 0.31 s
Time spent checking a path (1): 0.03 s

Number of procedures inlined: 1
Number of variables tracked: 2
Verifying program while tracking: {assertsPassed, x}
Starting forward approach...
  - underapprox
    - check
    - checked: Correct
  - overapprox
    - check
    - checked: Correct
--------- Stats ---------
number of functions inlined: 0
number of backtracking: 0
total number of assertions in Z3 stack: 0
total number of Z3 calls: 2
total time spent in Z3: (tick) 86
-------------------------
Program has no bugs

Boogie verification time: 0.21 s
Time spent reading-writing programs: 0.03 s

Time spent checking a program (2): 0.34 s
Time spent checking a path (1): 0.03 s

Number of procedures inlined: 0
Number of variables tracked: 2
Total Time: 0.6417966 s
Total User CPU time: 0.625 s

Query: SI algorithm may either return from an SAT Under-aproximate query or UNSAT over-approximate query. 
However, if an Under-approximate query is UNSAT and this query did not contain any blocking procedure calls, 
then SI algorithm can also return proving program as SAFE. This is demonstrated in test\regression\test1

Akash Reply: True. It would save us one less inlining. 


########## Meeting with Vincent #################
Cloud build -- Visual Studio code
Bash and batch -- if cygwin is configured correctly -- 

Build configurations
1> nmake -- just like make 
2> MS build configurations -- Through Visual Studio (API)
3> MSDN -- C# maps are called dictionary


############### Running SDV regression using Corral #####################

Results from Corral: Verification output : Correct means full verification, Proof means bounded verification.

Flags to be used with Corral present in the following file:
SdvBench/ITP_WDM/file_map.txt

Old SDV results in following file:
/MSR-Research/corral/SDV-regression/results.txt

Command line flag interpretation for Corral:
============================================
/k is the context-switch bound (does not matter for sequential programs)
/useProverEvaluate is how the Z3 model is queried for values of variables
/sdv controls the outer loop for corral. It simplifies a bunch of things knowing that the input came from SDV

TODO:
1> Run Akash's backtracking search with Buggy and Correct procedures - With and without Houdini. 
2> Run debugger to see the execution of the backtrack search
3> Write a proposal for Degree of freedom in the original algorithm


IMPLEMENTATION:
* Change the outer Hierarchical refinement loop and set it to MAX


Queries:
1> Does /newStratifiedInlining:split always have to be run with /di /doNotUseLabels option ?
2> Why does /newStratifiedInlining:split /di start with Over-approx and not Under-approx ?

Akash Response:
The SplitSearch implementation requires the /di flag, but only because it needs the call tree data structure that DI maintains. It doesn't do dag inlining 
C:\MSR-Research\corral>bin\Debug\corral.exe test\regression\test3\main.bpl /flags:test\regression\test3\config  
/trackAllVars /v:3 /newStratifiedInlining:split /di /doNotUseLabels

Query: Why are every query over-approximate in Splitsearch technique -- Ran on test3 ?
    Main
    | |
 ---  --- 
 |       |
foo     bar
 |       |
top     top


>>> Pushing Block(foo, 1, 0, 3, 2)
  - overapprox
    - check
    - checked: Correct
>>> Pop
>>> Pushing Must-Reach(foo)
 >>> Pushing Block(top, 1, 0, 6, 5)
  - overapprox
    - check
    - checked: Correct
 >>> Pop
 >>> Pushing Must-Reach(top)
  - overapprox
    - check
    - checked: Correct
 >>> Pop
>>> Pop

TODO: 
Figure out the VC for MustReach basic block for single procedure and for inter-precedural calls.
MustReach can be done at the level of basic blocks as well as call site. 


       Implementation
===========================
> Functions to look for -- private StratifiedVC Expand(StratifiedCallSite scs, string name, bool DoSubst, bool dontMerge)
> Look at Subhajit code for Parallelization infrastructure

Parallelization infrastructure
===============================
It is easier to use the thread pool provided by the .NET Framework through the ThreadPool class. 
https://www.dotnetperls.com/threadpool
https://msdn.microsoft.com/en-us/library/3dasc8as(v=vs.80).aspx
https://www.codeproject.com/articles/548865/create-a-custom-threadpool-in-csharp

Query:
1> How do we create a new Z3 instance in every thread. 
If I create this instance and then invoke the inlined procedure, does the push and pop inside that procedure uses this z3 instance ?
Should I pass ProverInterface or StratifiedInlining object to create separate VC generation data structures and separate prover instances. 
The signature of the method is : ThreadPool.QueueUserWorkItem(Compute_FwdNoUnder, prover1);
2> What is the object when we call push(); Does it only push prover.assert() statements. 

3> Why do Corral need to expand foo() and bar() even though none of them modifies x. 
In this case, the inlining is not property based. However, if the statement "x=1;assert x!= 1"
is before the call to foo() and bar(), then corral can successfully prove it unsafe without ]
expanding foo and bar.

 
procedure top()
modifies z;
{
   z := 1;
}

procedure foo()
modifies z,y;
{
   y := 1;
   call top();
}

procedure bar()
modifies z;
{
   z := 1;
   call top();
}


procedure {:entrypoint} main()
modifies x,y,z;
{
   call foo();
   call bar();
   x := 1;
   assert x !=  1;
}


Meeting on 18th August
======================
1> Run _fail cases with SI and split-search and report number of procedures inlined and time taken 
2> Give high level algorithm to Akash and Subhajit
High level algorithm
=====================
 pick c in Calltree
 EnqueueJob(mustReach, c)
 execute block(c)
 result = continue SI
 if(result == UNSAT) 
   Dequeue job from Queue and work on it.  

3> The aim is NOT to reduce the total number of inlinings, but to split the z3 query using 
threading.  Compared to normal SI, the split search always has simplied z3 queries. 

4> In UNSAFE cases, the normal SI always does FULL inlining of all procedure calls.
5> Push in z3 is like backtracking point.

Inform Akash
=============
Decisions are made during the run of the Stratified Inlining and not upfront. 

